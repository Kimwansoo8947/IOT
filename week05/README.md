초연결 사회와 4차 산업혁명
초연결 사회 => RFID, USN, 사물인터넷
1치 산업혁명 => 물류, 교통이 발전됨
2차 산업 혁명 => 전기에 의한 산업 구조의 변화로 대량생산이라는 새로운 체제로 접어든 시점
3차 산업 혁명 => 네트워크 도입
4차 산업 혁명 => 개인 맞춤형 서비스 제공

IoT의 개념
좁은 의미: 유비쿼터스 환경에서 사물끼리 통신을 주고 받는 것
넓은 의미: 인간, 사물, 서비스가 인간의 명시적 개입 없이 상호 협력해 센싱, 네트워킹, 정보 처리 등의 지능적 관계를 형성 하는 사물 공간 연결망

IoT의 요소 => 정보를 연결해서 서비스 제공
연결, 정보, 서비스

IoT의 주요 기술  
센싱 기술: 정보를 수집 처리 관리하고 이를 서비스로 구현하기 위한 환경을 지원하는 기술

센싱 기술의 특징
- 프로토콜의 이종성: 디바이스는 상이한 플랫폼에서 동작하는데, 이때 디바이스간 통신 프로토콜이 서로 다름 (즉, 하나로 통합하기 어렵다.)
- 민감한 데이터의 수집으로 인한 정보 보안 문제: 데이터의 대량 처리를 위해 정보보안을 유지해야함
- 자원제약성이 있음: 제한된 배터리 전력 수명으로 CPU나 메모리 등의 자원에 제약을 많이 받음 (아직까지 배터리 이슈가 존재함)
- 이동성이 있음: IoT 기기는 이동성이 높아 네트워크 토폴로지가 동적으로 만들어지는 경우가 많다. 센서 기기는 낮은 성는과 좁은 대역폭으로 연결성, 즉 데이터 품질이 좋지 않다.
  
- 유 무선통신 및 네트워크 인프라 기술
- 대표적인 근거리 통신기술은 WPAN으로, 지그비, 블루투스, NFC 등과 같은 무선통신기술이 해당된다.

- 협대역: WI-FI, 지그비, 블루투스: 커버리지는 적지만, 전송속도가 빠르다.
- 광대역: SigFox, LoRa, NB-IoT: 커버리지는 크지만, 전송속도가 느리다.

- 차세대 기술: 6LoWPAN, LoRa/NB-IoT  네트워크 등

- 좁은 대역폭 VS 넓은 대역폭
- 좁은 대역폭은 데이터 전송속도가 느리고 반면 넓은 대역폭은 데이터 전송속도가 빠르다.
- 전력 소모는 좁은 대역폭은 적고 넓은 대역폭은 많다.
- 주 사용 분야는 좁은 대역폭은 IoT 넓은 대역폭은 스마트폰이 있다.

- IoT 플랫폼
- 디바이스 플랫폼 => ex) 아두이노
- 연결 플랫폼 => ex) MQTT
- 데이터 플랫폼
- 서비스 플랫폼

- 사물 인터넷 개념
- 센서 -  물리적 환경의 변화를 감지하고 데이터 수집
- 엣지 디바이스 - 수집된 데이터를 처리하고 간단한 분석 수행 (게이트웨이 중간에 존재)
- 게이트웨이 - 엣지 디바이스와 서버(클라우드)간의 중계 역할 (통신)
- 서버/클라우드 - 데이터 저장, 분석 및 시각화

- 사물인터넷 활용 분야
- 스마트홈, 스마트 시티, 스마트 팩토리, 헬스케어
  
- 아두이노 변수
- bool : 0을 제외한 모든건 참 (참과 거짓을 표현하는 정수)
- int
- usigned long
- float
- char
- String
- String은 C++의 변수형이 아니라 입문자들이 쉽게 문자열을 다루도록 아두이노에서 만든 클래스입니다.

- 변수명은 숫자로 시작하면 안되고 중간에 빈칸이 있으면 안된다.
- 또한 여러 단어를 사용해서 변수명을 만들 경우 첫 단어는 소문자, 이후의 단어는 첫 글자만 대문자로 작성하는 낙타등 표기법(camel case) 사용한다.

 - 전역 변수: 변수를 setup()보다 앞에 선언하면 모든 영역에서 변수를 부를 수 있다. 이러한 변수를 전역 변수(global variable)라고 한다.
 - 전역 변수는 메모리가 끝까지 유지되며 가용 메모리가 줄어든다. (유지를 계속해줘야 되서)
 - 지역 변수: 대부분의 변수는 프로그램의 특정 함수에서만 사용된다. 지역 변수는 선언된 함수 또는 블록 안에서만 통용된다. (메모리 활용면에서 유리)

 - const (상수)
  변수 선언 시 값이 중간에 바뀌지 않는다면 변수형 앞에 const를 붙이는게 좋다.
 - static
  함수 안의 지역 변수라도 값이 유지되어야 하는 경우가 있다. static 변수는 값을 바꿀 수 있다.
  static으로 선언된 변수는 메모리에서 전역 변수처럼 관리된다.
  static으로 선언된 변수의 초기화는 최초 한번만 수행

 - bool
  c++에서 0은 거짓, 1은 참으로 예약되어 있으며 아두이노에서는 추가로 HIGH와 LOW를 각각 1과 0으로 지정했다.
  (음수도 참)

 - byte
  1바이트로 부호없이 정수 표현, 0에서 255까지 커버
  usigned char과 같은 의미이다.

 - uint8_t
  typedef라는 지시어를 이용해 정의한 데이터 형으로 unsigned int 8bit type이란 뜻이다.

  - 배열
  - 배열의 첫 번째 요소의 첨자 (인덱스)가 0인 것을 주의한다.

  - float temp[3] = {}; 이와 같이 지정하면 모든 요소가 0으로 초기화된다.
  - c언어에서는 float temp[3] = {0,};

  - char
  - 아두이노에서 한글은 크기가 3바이트로 char로 선언된 변수에 보관할 수 없다. 단, 영문은 가능하다.
  
  - char a = '2'
  - a - 48 = 2
  - a = 50
  - a = 50  48 = '0'

  - char는 속성상 8비트의 부호가 있는 정수이므로 연산이 가능하다 Serial.println()에서 char형의 변수는 문자로 출력되므로 정수로 바꾸고 싶다면 형 변환 표시를 해야 한다.

  - char 배열
  - 배열 이름은 배열의 첫 요소의 주소로 나타내는 변수로 취급된다.

  - char 배열을 다루는 함수
  - 복사 strcpy(char 배열, char 배열|char 포인터) 첫 인수에 두 번째 인수의 값을 복사함 (첫 인수에 원래 있던 값은 없어짐)
  - 연결 strcat(char 배열, char 배열|char 포인터) 첫 인수에 두번째 인수의 값을 덧붙임
  - 길이 strlen(char 배열 | char 포인터) 인수의 문자 개수를 돌려줌
  - 비교 strcmp(char 배열| char 포인터, char 배열| char 포인터) 1,0,-1의 숫자를 돌려줌 1: 첫 인수가 클때, 0 두 인수가 같을 때, -1: 첫 인수가 작을때

  - char 배열과 char 포인터의 사용사례
  - char ssid[] = "mySsid";
  - char pass[] = "myStrongPassword";

  - char * ssid = "mySsid";
  - char * pass = "myStrongPassword";

  - char  포인터를 사용해도 결과는 같다.
  - 값을 고정하기 위한 상수로 char 배열이나 char 포인터를 사용할 경우 const를 붙이는 것이 좋다.

  - 다른 변수형을 스트링으로 변환하기
  - 상수나 변수를 String으로 감싸도 스트링으로 변환된다.
    
  - 스트링에서 값 골라내기
  - String longstr = "9:08:35,27.6"
  - int p1 = longstr.indexof(":") // 처음부터 (왼쪽부터)
  - int p2 = longstr.indexof(":", p1+1) // p1+1 부터
  - int p3 = longstr.indexof(",") // 처음부터

  - substring()은 정해진 범위의 문자열을 돌려준다.

  - a = "10"           메소드
  - (int) a            a.toInt() => 메소드는 그룹화 되어 있어서 유효성 검사가 가능하다.

  - 직렬: 한번애 한 바이트씩 순차적으로 전송
  - 직렬에는 동기식과 비동기식이 있다.
  - 동기식애는 I2C, SPI
  - 비동기식에는 UART가 있다  비동기식이 속도가 빠르다.
  - 병렬 통신은 한번에 여러개 전송한다.

  - begin()
  - Serial 오브젝트 사용을 위한 보 레이트(baud rate) 지정에는 begin()을 사용한다.
  - 송신 수신 보 레이트 둘 다 맞춰져야한다.

  - write() (중요)
  - byte b = 97; // 아스키 값 97: 'a'
  - Serial.prinln(b); // 97
  - Serial.write(b) // a

  - Serial.write()는 메모리의 내용을 그대로 보낸다. 숫자 97은 아스키 코드로 'a'를 뜻한다.

  - Serial의 입력 메소드
  - readStringUntil(끝 표시 문자) : 끝 문자로 표시된 문자가 나오기 전까지 읽어서 지정한 배열에 삽입 ('\0' 주로 사용)

  - 입력한 내용을 그대로 출력하기
  - while (Serial.available()){ // 버퍼에 값이 있으면 True 아니면 False
      char c = Serial.read();
    // 후속 처리리
  
  } 

  - 모니터에 데이터를 입력하면 보드의 수신 버퍼에 도착한다. 프로그램은 Serial.available()을 통해 문자수를 확인한다.
  - 문자수가 0이 아니면 Serial.read()를 호출하여 하나씩 읽어온다.
  - Serial.available()이 알려주는 숫자는 1씩 줄어드는데 0이 되면 while()을 벗어난다.
  
